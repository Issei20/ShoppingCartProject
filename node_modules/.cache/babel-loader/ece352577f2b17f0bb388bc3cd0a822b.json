{"ast":null,"code":"import * as React from 'react';\nimport { useReducer, useEffect, useRef } from 'react';\nconst ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\nconst ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n\nconst useForceUpdate = () => useReducer(() => ({}))[1];\n\nconst notImplemented = name => () => {\n  const msg = `Hook \"${name}\" no possible to using inside useBetween scope.`;\n  console.error(msg);\n  throw new Error(msg);\n};\n\nconst equals = (a, b) => Object.is(a, b);\n\nconst shouldUpdate = (a, b) => !a || !b || a.length !== b.length || a.some((dep, index) => !equals(dep, b[index]));\n\nconst detectServer = () => typeof window === 'undefined';\n\nconst instances = new Map();\nlet boxes = [];\nlet pointer = 0;\nlet useEffectQueue = [];\nlet useLayoutEffectQueue = [];\n\nlet nextTick = () => {};\n\nlet isServer = detectServer();\nlet initialData = undefined;\n\nconst nextBox = () => {\n  const index = pointer++;\n  return boxes[index] = boxes[index] || {};\n};\n\nconst ownDisptacher = {\n  useState(initialState) {\n    const box = nextBox();\n    const tick = nextTick;\n\n    if (!box.initialized) {\n      box.state = typeof initialState === \"function\" ? initialState() : initialState;\n\n      box.set = fn => {\n        if (typeof fn === 'function') {\n          return box.set(fn(box.state));\n        }\n\n        if (!equals(fn, box.state)) {\n          box.state = fn;\n          tick();\n        }\n      };\n\n      box.initialized = true;\n    }\n\n    return [box.state, box.set];\n  },\n\n  useReducer(reducer, initialState, init) {\n    const box = nextBox();\n    const tick = nextTick;\n\n    if (!box.initialized) {\n      box.state = init ? init(initialState) : initialState;\n\n      box.dispatch = action => {\n        const state = reducer(box.state, action);\n\n        if (!equals(state, box.state)) {\n          box.state = state;\n          tick();\n        }\n      };\n\n      box.initialized = true;\n    }\n\n    return [box.state, box.dispatch];\n  },\n\n  useEffect(fn, deps) {\n    if (isServer) return;\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.deps = deps;\n      box.initialized = true;\n      useEffectQueue.push([box, deps, fn]);\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      useEffectQueue.push([box, deps, fn]);\n    }\n  },\n\n  useLayoutEffect(fn, deps) {\n    if (isServer) return;\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.deps = deps;\n      box.initialized = true;\n      useLayoutEffectQueue.push([box, deps, fn]);\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      useLayoutEffectQueue.push([box, deps, fn]);\n    }\n  },\n\n  useCallback(fn, deps) {\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.fn = fn;\n      box.deps = deps;\n      box.initialized = true;\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      box.fn = fn;\n    }\n\n    return box.fn;\n  },\n\n  useMemo(fn, deps) {\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.deps = deps;\n      box.state = fn();\n      box.initialized = true;\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      box.state = fn();\n    }\n\n    return box.state;\n  },\n\n  useRef(initialValue) {\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.state = {\n        current: initialValue\n      };\n      box.initialized = true;\n    }\n\n    return box.state;\n  },\n\n  useImperativeHandle(ref, fn, deps) {\n    if (isServer) return;\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.deps = deps;\n      box.initialized = true;\n      useLayoutEffectQueue.push([box, deps, () => {\n        typeof ref === 'function' ? ref(fn()) : ref.current = fn();\n      }]);\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      useLayoutEffectQueue.push([box, deps, () => {\n        typeof ref === 'function' ? ref(fn()) : ref.current = fn();\n      }]);\n    }\n  }\n\n};\n['readContext', 'useContext', 'useDebugValue', 'useResponder', 'useDeferredValue', 'useTransition'].forEach(key => ownDisptacher[key] = notImplemented(key));\n\nconst factory = hook => {\n  const scopedBoxes = [];\n  let syncs = [];\n  let state = undefined;\n  let unsubs = [];\n\n  const sync = () => {\n    syncs.slice().forEach(fn => fn());\n  };\n\n  const tick = () => {\n    const originDispatcher = ReactCurrentDispatcher.current;\n    const originState = [pointer, useEffectQueue, useLayoutEffectQueue, boxes, nextTick];\n    let tickAgain = false;\n    let tickBody = true;\n    pointer = 0;\n    useEffectQueue = [];\n    useLayoutEffectQueue = [];\n    boxes = scopedBoxes;\n\n    nextTick = () => {\n      if (tickBody) {\n        tickAgain = true;\n      } else {\n        tick();\n      }\n    };\n\n    ReactCurrentDispatcher.current = ownDisptacher;\n    state = hook(initialData);\n    [useLayoutEffectQueue, useEffectQueue].forEach(queue => queue.forEach(_ref => {\n      let [box, deps, fn] = _ref;\n      box.deps = deps;\n\n      if (box.unsub) {\n        const unsub = box.unsub;\n        unsubs = unsubs.filter(fn => fn !== unsub);\n        unsub();\n      }\n\n      const unsub = fn();\n\n      if (typeof unsub === \"function\") {\n        unsubs.push(unsub);\n        box.unsub = unsub;\n      } else {\n        box.unsub = null;\n      }\n    }));\n    [pointer, useEffectQueue, useLayoutEffectQueue, boxes, nextTick] = originState;\n    ReactCurrentDispatcher.current = originDispatcher;\n    tickBody = false;\n\n    if (!tickAgain) {\n      sync();\n      return;\n    }\n\n    tick();\n  };\n\n  const sub = fn => {\n    syncs.push(fn);\n  };\n\n  const unsub = fn => {\n    syncs = syncs.filter(f => f !== fn);\n  };\n\n  return {\n    init: () => tick(),\n    get: () => state,\n    sub,\n    unsub,\n    unsubs: () => unsubs\n  };\n};\n\nconst getInstance = hook => {\n  let inst = instances.get(hook);\n\n  if (!inst) {\n    inst = factory(hook);\n    instances.set(hook, inst);\n    inst.init();\n  }\n\n  return inst;\n};\n\nconst useBetween = hook => {\n  const forceUpdate = useForceUpdate();\n  let inst = getInstance(hook);\n  useEffect(() => (inst.sub(forceUpdate), () => inst.unsub(forceUpdate)), [inst]);\n  return inst.get();\n};\n\nconst useInitial = (data, server) => {\n  const ref = useRef();\n\n  if (!ref.current) {\n    isServer = typeof server === 'undefined' ? detectServer() : server;\n    isServer && clear();\n    initialData = data;\n    ref.current = 1;\n  }\n};\n\nconst get = hook => getInstance(hook).get();\n\nconst free = function () {\n  for (var _len = arguments.length, hooks = new Array(_len), _key = 0; _key < _len; _key++) {\n    hooks[_key] = arguments[_key];\n  }\n\n  if (!hooks.length) {\n    hooks = [];\n    instances.forEach((_instance, hook) => hooks.push(hook));\n  }\n\n  let inst;\n  hooks.forEach(hook => (inst = instances.get(hook)) && inst.unsubs().slice().forEach(fn => fn()));\n  hooks.forEach(hook => instances.delete(hook));\n};\n\nconst clear = () => instances.clear();\n\nconst on = (hook, fn) => {\n  const inst = getInstance(hook);\n\n  const listener = () => fn(inst.get());\n\n  inst.sub(listener);\n  return () => inst.unsub(listener);\n};\n\nconst act = fn => Promise.resolve(fn());\n\nexport { act, clear, free, get, on, useBetween, useInitial };","map":{"version":3,"sources":["/home/atsal/router/node_modules/use-between/release/index.esm.js"],"names":["React","useReducer","useEffect","useRef","ReactSharedInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","useForceUpdate","notImplemented","name","msg","console","error","Error","equals","a","b","Object","is","shouldUpdate","length","some","dep","index","detectServer","window","instances","Map","boxes","pointer","useEffectQueue","useLayoutEffectQueue","nextTick","isServer","initialData","undefined","nextBox","ownDisptacher","useState","initialState","box","tick","initialized","state","set","fn","reducer","init","dispatch","action","deps","push","useLayoutEffect","useCallback","useMemo","initialValue","current","useImperativeHandle","ref","forEach","key","factory","hook","scopedBoxes","syncs","unsubs","sync","slice","originDispatcher","originState","tickAgain","tickBody","queue","unsub","filter","sub","f","get","getInstance","inst","useBetween","forceUpdate","useInitial","data","server","clear","free","hooks","_instance","delete","on","listener","act","Promise","resolve"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { useReducer, useEffect, useRef } from 'react';\n\nconst ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\r\nconst ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n\nconst useForceUpdate = () => useReducer(() => ({}))[1];\n\nconst notImplemented = (name) => () => {\r\n    const msg = `Hook \"${name}\" no possible to using inside useBetween scope.`;\r\n    console.error(msg);\r\n    throw new Error(msg);\r\n};\r\nconst equals = (a, b) => Object.is(a, b);\r\nconst shouldUpdate = (a, b) => ((!a || !b) ||\r\n    (a.length !== b.length) ||\r\n    a.some((dep, index) => !equals(dep, b[index])));\r\nconst detectServer = () => typeof window === 'undefined';\r\nconst instances = new Map();\r\nlet boxes = [];\r\nlet pointer = 0;\r\nlet useEffectQueue = [];\r\nlet useLayoutEffectQueue = [];\r\nlet nextTick = () => { };\r\nlet isServer = detectServer();\r\nlet initialData = undefined;\r\nconst nextBox = () => {\r\n    const index = pointer++;\r\n    return (boxes[index] = boxes[index] || {});\r\n};\r\nconst ownDisptacher = {\r\n    useState(initialState) {\r\n        const box = nextBox();\r\n        const tick = nextTick;\r\n        if (!box.initialized) {\r\n            box.state = typeof initialState === \"function\" ? initialState() : initialState;\r\n            box.set = (fn) => {\r\n                if (typeof fn === 'function') {\r\n                    return box.set(fn(box.state));\r\n                }\r\n                if (!equals(fn, box.state)) {\r\n                    box.state = fn;\r\n                    tick();\r\n                }\r\n            };\r\n            box.initialized = true;\r\n        }\r\n        return [box.state, box.set];\r\n    },\r\n    useReducer(reducer, initialState, init) {\r\n        const box = nextBox();\r\n        const tick = nextTick;\r\n        if (!box.initialized) {\r\n            box.state = init ? init(initialState) : initialState;\r\n            box.dispatch = (action) => {\r\n                const state = reducer(box.state, action);\r\n                if (!equals(state, box.state)) {\r\n                    box.state = state;\r\n                    tick();\r\n                }\r\n            };\r\n            box.initialized = true;\r\n        }\r\n        return [box.state, box.dispatch];\r\n    },\r\n    useEffect(fn, deps) {\r\n        if (isServer)\r\n            return;\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.deps = deps;\r\n            box.initialized = true;\r\n            useEffectQueue.push([box, deps, fn]);\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            useEffectQueue.push([box, deps, fn]);\r\n        }\r\n    },\r\n    useLayoutEffect(fn, deps) {\r\n        if (isServer)\r\n            return;\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.deps = deps;\r\n            box.initialized = true;\r\n            useLayoutEffectQueue.push([box, deps, fn]);\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            useLayoutEffectQueue.push([box, deps, fn]);\r\n        }\r\n    },\r\n    useCallback(fn, deps) {\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.fn = fn;\r\n            box.deps = deps;\r\n            box.initialized = true;\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            box.fn = fn;\r\n        }\r\n        return box.fn;\r\n    },\r\n    useMemo(fn, deps) {\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.deps = deps;\r\n            box.state = fn();\r\n            box.initialized = true;\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            box.state = fn();\r\n        }\r\n        return box.state;\r\n    },\r\n    useRef(initialValue) {\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.state = { current: initialValue };\r\n            box.initialized = true;\r\n        }\r\n        return box.state;\r\n    },\r\n    useImperativeHandle(ref, fn, deps) {\r\n        if (isServer)\r\n            return;\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.deps = deps;\r\n            box.initialized = true;\r\n            useLayoutEffectQueue.push([box, deps, () => {\r\n                    typeof ref === 'function' ? ref(fn()) : ref.current = fn();\r\n                }]);\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            useLayoutEffectQueue.push([box, deps, () => {\r\n                    typeof ref === 'function' ? ref(fn()) : ref.current = fn();\r\n                }]);\r\n        }\r\n    }\r\n};\r\n[\r\n    'readContext',\r\n    'useContext',\r\n    'useDebugValue',\r\n    'useResponder',\r\n    'useDeferredValue',\r\n    'useTransition'\r\n].forEach(key => ownDisptacher[key] = notImplemented(key));\r\nconst factory = (hook) => {\r\n    const scopedBoxes = [];\r\n    let syncs = [];\r\n    let state = undefined;\r\n    let unsubs = [];\r\n    const sync = () => {\r\n        syncs.slice().forEach(fn => fn());\r\n    };\r\n    const tick = () => {\r\n        const originDispatcher = ReactCurrentDispatcher.current;\r\n        const originState = [\r\n            pointer,\r\n            useEffectQueue,\r\n            useLayoutEffectQueue,\r\n            boxes,\r\n            nextTick\r\n        ];\r\n        let tickAgain = false;\r\n        let tickBody = true;\r\n        pointer = 0;\r\n        useEffectQueue = [];\r\n        useLayoutEffectQueue = [];\r\n        boxes = scopedBoxes;\r\n        nextTick = () => {\r\n            if (tickBody) {\r\n                tickAgain = true;\r\n            }\r\n            else {\r\n                tick();\r\n            }\r\n        };\r\n        ReactCurrentDispatcher.current = ownDisptacher;\r\n        state = hook(initialData);\r\n        [useLayoutEffectQueue, useEffectQueue].forEach(queue => (queue.forEach(([box, deps, fn]) => {\r\n            box.deps = deps;\r\n            if (box.unsub) {\r\n                const unsub = box.unsub;\r\n                unsubs = unsubs.filter(fn => fn !== unsub);\r\n                unsub();\r\n            }\r\n            const unsub = fn();\r\n            if (typeof unsub === \"function\") {\r\n                unsubs.push(unsub);\r\n                box.unsub = unsub;\r\n            }\r\n            else {\r\n                box.unsub = null;\r\n            }\r\n        })));\r\n        [\r\n            pointer,\r\n            useEffectQueue,\r\n            useLayoutEffectQueue,\r\n            boxes,\r\n            nextTick\r\n        ] = originState;\r\n        ReactCurrentDispatcher.current = originDispatcher;\r\n        tickBody = false;\r\n        if (!tickAgain) {\r\n            sync();\r\n            return;\r\n        }\r\n        tick();\r\n    };\r\n    const sub = (fn) => {\r\n        syncs.push(fn);\r\n    };\r\n    const unsub = (fn) => {\r\n        syncs = syncs.filter(f => f !== fn);\r\n    };\r\n    return {\r\n        init: () => tick(),\r\n        get: () => state,\r\n        sub,\r\n        unsub,\r\n        unsubs: () => unsubs\r\n    };\r\n};\r\nconst getInstance = (hook) => {\r\n    let inst = instances.get(hook);\r\n    if (!inst) {\r\n        inst = factory(hook);\r\n        instances.set(hook, inst);\r\n        inst.init();\r\n    }\r\n    return inst;\r\n};\r\nconst useBetween = (hook) => {\r\n    const forceUpdate = useForceUpdate();\r\n    let inst = getInstance(hook);\r\n    useEffect(() => (inst.sub(forceUpdate), () => inst.unsub(forceUpdate)), [inst]);\r\n    return inst.get();\r\n};\r\nconst useInitial = (data, server) => {\r\n    const ref = useRef();\r\n    if (!ref.current) {\r\n        isServer = typeof server === 'undefined' ? detectServer() : server;\r\n        isServer && clear();\r\n        initialData = data;\r\n        ref.current = 1;\r\n    }\r\n};\r\nconst get = (hook) => getInstance(hook).get();\r\nconst free = function (...hooks) {\r\n    if (!hooks.length) {\r\n        hooks = [];\r\n        instances.forEach((_instance, hook) => hooks.push(hook));\r\n    }\r\n    let inst;\r\n    hooks.forEach((hook) => ((inst = instances.get(hook)) &&\r\n        inst.unsubs().slice().forEach((fn) => fn())));\r\n    hooks.forEach((hook) => instances.delete(hook));\r\n};\r\nconst clear = () => instances.clear();\r\nconst on = (hook, fn) => {\r\n    const inst = getInstance(hook);\r\n    const listener = () => fn(inst.get());\r\n    inst.sub(listener);\r\n    return () => inst.unsub(listener);\r\n};\r\nconst act = (fn) => Promise.resolve(fn());\n\nexport { act, clear, free, get, on, useBetween, useInitial };\n"]},"metadata":{},"sourceType":"module"}